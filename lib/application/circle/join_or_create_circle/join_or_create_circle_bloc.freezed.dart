// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'join_or_create_circle_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$JoinOrCreateCircleEventTearOff {
  const _$JoinOrCreateCircleEventTearOff();

// ignore: unused_element
  StartSearching startSearching() {
    return const StartSearching();
  }

// ignore: unused_element
  StopSearching stopSearching() {
    return const StopSearching();
  }

// ignore: unused_element
  CreateCircle createCircle() {
    return const CreateCircle();
  }

// ignore: unused_element
  JoinCircle joinCircle() {
    return const JoinCircle();
  }
}

// ignore: unused_element
const $JoinOrCreateCircleEvent = _$JoinOrCreateCircleEventTearOff();

mixin _$JoinOrCreateCircleEvent {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result startSearching(),
    @required Result stopSearching(),
    @required Result createCircle(),
    @required Result joinCircle(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result startSearching(),
    Result stopSearching(),
    Result createCircle(),
    Result joinCircle(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result startSearching(StartSearching value),
    @required Result stopSearching(StopSearching value),
    @required Result createCircle(CreateCircle value),
    @required Result joinCircle(JoinCircle value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result startSearching(StartSearching value),
    Result stopSearching(StopSearching value),
    Result createCircle(CreateCircle value),
    Result joinCircle(JoinCircle value),
    @required Result orElse(),
  });
}

abstract class $JoinOrCreateCircleEventCopyWith<$Res> {
  factory $JoinOrCreateCircleEventCopyWith(JoinOrCreateCircleEvent value,
          $Res Function(JoinOrCreateCircleEvent) then) =
      _$JoinOrCreateCircleEventCopyWithImpl<$Res>;
}

class _$JoinOrCreateCircleEventCopyWithImpl<$Res>
    implements $JoinOrCreateCircleEventCopyWith<$Res> {
  _$JoinOrCreateCircleEventCopyWithImpl(this._value, this._then);

  final JoinOrCreateCircleEvent _value;
  // ignore: unused_field
  final $Res Function(JoinOrCreateCircleEvent) _then;
}

abstract class $StartSearchingCopyWith<$Res> {
  factory $StartSearchingCopyWith(
          StartSearching value, $Res Function(StartSearching) then) =
      _$StartSearchingCopyWithImpl<$Res>;
}

class _$StartSearchingCopyWithImpl<$Res>
    extends _$JoinOrCreateCircleEventCopyWithImpl<$Res>
    implements $StartSearchingCopyWith<$Res> {
  _$StartSearchingCopyWithImpl(
      StartSearching _value, $Res Function(StartSearching) _then)
      : super(_value, (v) => _then(v as StartSearching));

  @override
  StartSearching get _value => super._value as StartSearching;
}

class _$StartSearching implements StartSearching {
  const _$StartSearching();

  @override
  String toString() {
    return 'JoinOrCreateCircleEvent.startSearching()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is StartSearching);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result startSearching(),
    @required Result stopSearching(),
    @required Result createCircle(),
    @required Result joinCircle(),
  }) {
    assert(startSearching != null);
    assert(stopSearching != null);
    assert(createCircle != null);
    assert(joinCircle != null);
    return startSearching();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result startSearching(),
    Result stopSearching(),
    Result createCircle(),
    Result joinCircle(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (startSearching != null) {
      return startSearching();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result startSearching(StartSearching value),
    @required Result stopSearching(StopSearching value),
    @required Result createCircle(CreateCircle value),
    @required Result joinCircle(JoinCircle value),
  }) {
    assert(startSearching != null);
    assert(stopSearching != null);
    assert(createCircle != null);
    assert(joinCircle != null);
    return startSearching(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result startSearching(StartSearching value),
    Result stopSearching(StopSearching value),
    Result createCircle(CreateCircle value),
    Result joinCircle(JoinCircle value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (startSearching != null) {
      return startSearching(this);
    }
    return orElse();
  }
}

abstract class StartSearching implements JoinOrCreateCircleEvent {
  const factory StartSearching() = _$StartSearching;
}

abstract class $StopSearchingCopyWith<$Res> {
  factory $StopSearchingCopyWith(
          StopSearching value, $Res Function(StopSearching) then) =
      _$StopSearchingCopyWithImpl<$Res>;
}

class _$StopSearchingCopyWithImpl<$Res>
    extends _$JoinOrCreateCircleEventCopyWithImpl<$Res>
    implements $StopSearchingCopyWith<$Res> {
  _$StopSearchingCopyWithImpl(
      StopSearching _value, $Res Function(StopSearching) _then)
      : super(_value, (v) => _then(v as StopSearching));

  @override
  StopSearching get _value => super._value as StopSearching;
}

class _$StopSearching implements StopSearching {
  const _$StopSearching();

  @override
  String toString() {
    return 'JoinOrCreateCircleEvent.stopSearching()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is StopSearching);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result startSearching(),
    @required Result stopSearching(),
    @required Result createCircle(),
    @required Result joinCircle(),
  }) {
    assert(startSearching != null);
    assert(stopSearching != null);
    assert(createCircle != null);
    assert(joinCircle != null);
    return stopSearching();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result startSearching(),
    Result stopSearching(),
    Result createCircle(),
    Result joinCircle(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (stopSearching != null) {
      return stopSearching();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result startSearching(StartSearching value),
    @required Result stopSearching(StopSearching value),
    @required Result createCircle(CreateCircle value),
    @required Result joinCircle(JoinCircle value),
  }) {
    assert(startSearching != null);
    assert(stopSearching != null);
    assert(createCircle != null);
    assert(joinCircle != null);
    return stopSearching(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result startSearching(StartSearching value),
    Result stopSearching(StopSearching value),
    Result createCircle(CreateCircle value),
    Result joinCircle(JoinCircle value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (stopSearching != null) {
      return stopSearching(this);
    }
    return orElse();
  }
}

abstract class StopSearching implements JoinOrCreateCircleEvent {
  const factory StopSearching() = _$StopSearching;
}

abstract class $CreateCircleCopyWith<$Res> {
  factory $CreateCircleCopyWith(
          CreateCircle value, $Res Function(CreateCircle) then) =
      _$CreateCircleCopyWithImpl<$Res>;
}

class _$CreateCircleCopyWithImpl<$Res>
    extends _$JoinOrCreateCircleEventCopyWithImpl<$Res>
    implements $CreateCircleCopyWith<$Res> {
  _$CreateCircleCopyWithImpl(
      CreateCircle _value, $Res Function(CreateCircle) _then)
      : super(_value, (v) => _then(v as CreateCircle));

  @override
  CreateCircle get _value => super._value as CreateCircle;
}

class _$CreateCircle implements CreateCircle {
  const _$CreateCircle();

  @override
  String toString() {
    return 'JoinOrCreateCircleEvent.createCircle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CreateCircle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result startSearching(),
    @required Result stopSearching(),
    @required Result createCircle(),
    @required Result joinCircle(),
  }) {
    assert(startSearching != null);
    assert(stopSearching != null);
    assert(createCircle != null);
    assert(joinCircle != null);
    return createCircle();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result startSearching(),
    Result stopSearching(),
    Result createCircle(),
    Result joinCircle(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (createCircle != null) {
      return createCircle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result startSearching(StartSearching value),
    @required Result stopSearching(StopSearching value),
    @required Result createCircle(CreateCircle value),
    @required Result joinCircle(JoinCircle value),
  }) {
    assert(startSearching != null);
    assert(stopSearching != null);
    assert(createCircle != null);
    assert(joinCircle != null);
    return createCircle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result startSearching(StartSearching value),
    Result stopSearching(StopSearching value),
    Result createCircle(CreateCircle value),
    Result joinCircle(JoinCircle value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (createCircle != null) {
      return createCircle(this);
    }
    return orElse();
  }
}

abstract class CreateCircle implements JoinOrCreateCircleEvent {
  const factory CreateCircle() = _$CreateCircle;
}

abstract class $JoinCircleCopyWith<$Res> {
  factory $JoinCircleCopyWith(
          JoinCircle value, $Res Function(JoinCircle) then) =
      _$JoinCircleCopyWithImpl<$Res>;
}

class _$JoinCircleCopyWithImpl<$Res>
    extends _$JoinOrCreateCircleEventCopyWithImpl<$Res>
    implements $JoinCircleCopyWith<$Res> {
  _$JoinCircleCopyWithImpl(JoinCircle _value, $Res Function(JoinCircle) _then)
      : super(_value, (v) => _then(v as JoinCircle));

  @override
  JoinCircle get _value => super._value as JoinCircle;
}

class _$JoinCircle implements JoinCircle {
  const _$JoinCircle();

  @override
  String toString() {
    return 'JoinOrCreateCircleEvent.joinCircle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is JoinCircle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result startSearching(),
    @required Result stopSearching(),
    @required Result createCircle(),
    @required Result joinCircle(),
  }) {
    assert(startSearching != null);
    assert(stopSearching != null);
    assert(createCircle != null);
    assert(joinCircle != null);
    return joinCircle();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result startSearching(),
    Result stopSearching(),
    Result createCircle(),
    Result joinCircle(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (joinCircle != null) {
      return joinCircle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result startSearching(StartSearching value),
    @required Result stopSearching(StopSearching value),
    @required Result createCircle(CreateCircle value),
    @required Result joinCircle(JoinCircle value),
  }) {
    assert(startSearching != null);
    assert(stopSearching != null);
    assert(createCircle != null);
    assert(joinCircle != null);
    return joinCircle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result startSearching(StartSearching value),
    Result stopSearching(StopSearching value),
    Result createCircle(CreateCircle value),
    Result joinCircle(JoinCircle value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (joinCircle != null) {
      return joinCircle(this);
    }
    return orElse();
  }
}

abstract class JoinCircle implements JoinOrCreateCircleEvent {
  const factory JoinCircle() = _$JoinCircle;
}

class _$JoinOrCreateCircleStateTearOff {
  const _$JoinOrCreateCircleStateTearOff();

// ignore: unused_element
  _JoinOrCreateCircleState call(
      {@required
          bool isSearching,
      @required
          bool isJoining,
      @required
          bool isCreating,
      @required
          Option<Either<ConnectionFailure, Unit>>
              connectionFailureOrSuccessOption}) {
    return _JoinOrCreateCircleState(
      isSearching: isSearching,
      isJoining: isJoining,
      isCreating: isCreating,
      connectionFailureOrSuccessOption: connectionFailureOrSuccessOption,
    );
  }
}

// ignore: unused_element
const $JoinOrCreateCircleState = _$JoinOrCreateCircleStateTearOff();

mixin _$JoinOrCreateCircleState {
  bool get isSearching;
  bool get isJoining;
  bool get isCreating;
  Option<Either<ConnectionFailure, Unit>> get connectionFailureOrSuccessOption;

  $JoinOrCreateCircleStateCopyWith<JoinOrCreateCircleState> get copyWith;
}

abstract class $JoinOrCreateCircleStateCopyWith<$Res> {
  factory $JoinOrCreateCircleStateCopyWith(JoinOrCreateCircleState value,
          $Res Function(JoinOrCreateCircleState) then) =
      _$JoinOrCreateCircleStateCopyWithImpl<$Res>;
  $Res call(
      {bool isSearching,
      bool isJoining,
      bool isCreating,
      Option<Either<ConnectionFailure, Unit>>
          connectionFailureOrSuccessOption});
}

class _$JoinOrCreateCircleStateCopyWithImpl<$Res>
    implements $JoinOrCreateCircleStateCopyWith<$Res> {
  _$JoinOrCreateCircleStateCopyWithImpl(this._value, this._then);

  final JoinOrCreateCircleState _value;
  // ignore: unused_field
  final $Res Function(JoinOrCreateCircleState) _then;

  @override
  $Res call({
    Object isSearching = freezed,
    Object isJoining = freezed,
    Object isCreating = freezed,
    Object connectionFailureOrSuccessOption = freezed,
  }) {
    return _then(_value.copyWith(
      isSearching:
          isSearching == freezed ? _value.isSearching : isSearching as bool,
      isJoining: isJoining == freezed ? _value.isJoining : isJoining as bool,
      isCreating:
          isCreating == freezed ? _value.isCreating : isCreating as bool,
      connectionFailureOrSuccessOption:
          connectionFailureOrSuccessOption == freezed
              ? _value.connectionFailureOrSuccessOption
              : connectionFailureOrSuccessOption
                  as Option<Either<ConnectionFailure, Unit>>,
    ));
  }
}

abstract class _$JoinOrCreateCircleStateCopyWith<$Res>
    implements $JoinOrCreateCircleStateCopyWith<$Res> {
  factory _$JoinOrCreateCircleStateCopyWith(_JoinOrCreateCircleState value,
          $Res Function(_JoinOrCreateCircleState) then) =
      __$JoinOrCreateCircleStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {bool isSearching,
      bool isJoining,
      bool isCreating,
      Option<Either<ConnectionFailure, Unit>>
          connectionFailureOrSuccessOption});
}

class __$JoinOrCreateCircleStateCopyWithImpl<$Res>
    extends _$JoinOrCreateCircleStateCopyWithImpl<$Res>
    implements _$JoinOrCreateCircleStateCopyWith<$Res> {
  __$JoinOrCreateCircleStateCopyWithImpl(_JoinOrCreateCircleState _value,
      $Res Function(_JoinOrCreateCircleState) _then)
      : super(_value, (v) => _then(v as _JoinOrCreateCircleState));

  @override
  _JoinOrCreateCircleState get _value =>
      super._value as _JoinOrCreateCircleState;

  @override
  $Res call({
    Object isSearching = freezed,
    Object isJoining = freezed,
    Object isCreating = freezed,
    Object connectionFailureOrSuccessOption = freezed,
  }) {
    return _then(_JoinOrCreateCircleState(
      isSearching:
          isSearching == freezed ? _value.isSearching : isSearching as bool,
      isJoining: isJoining == freezed ? _value.isJoining : isJoining as bool,
      isCreating:
          isCreating == freezed ? _value.isCreating : isCreating as bool,
      connectionFailureOrSuccessOption:
          connectionFailureOrSuccessOption == freezed
              ? _value.connectionFailureOrSuccessOption
              : connectionFailureOrSuccessOption
                  as Option<Either<ConnectionFailure, Unit>>,
    ));
  }
}

class _$_JoinOrCreateCircleState implements _JoinOrCreateCircleState {
  const _$_JoinOrCreateCircleState(
      {@required this.isSearching,
      @required this.isJoining,
      @required this.isCreating,
      @required this.connectionFailureOrSuccessOption})
      : assert(isSearching != null),
        assert(isJoining != null),
        assert(isCreating != null),
        assert(connectionFailureOrSuccessOption != null);

  @override
  final bool isSearching;
  @override
  final bool isJoining;
  @override
  final bool isCreating;
  @override
  final Option<Either<ConnectionFailure, Unit>>
      connectionFailureOrSuccessOption;

  @override
  String toString() {
    return 'JoinOrCreateCircleState(isSearching: $isSearching, isJoining: $isJoining, isCreating: $isCreating, connectionFailureOrSuccessOption: $connectionFailureOrSuccessOption)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _JoinOrCreateCircleState &&
            (identical(other.isSearching, isSearching) ||
                const DeepCollectionEquality()
                    .equals(other.isSearching, isSearching)) &&
            (identical(other.isJoining, isJoining) ||
                const DeepCollectionEquality()
                    .equals(other.isJoining, isJoining)) &&
            (identical(other.isCreating, isCreating) ||
                const DeepCollectionEquality()
                    .equals(other.isCreating, isCreating)) &&
            (identical(other.connectionFailureOrSuccessOption,
                    connectionFailureOrSuccessOption) ||
                const DeepCollectionEquality().equals(
                    other.connectionFailureOrSuccessOption,
                    connectionFailureOrSuccessOption)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(isSearching) ^
      const DeepCollectionEquality().hash(isJoining) ^
      const DeepCollectionEquality().hash(isCreating) ^
      const DeepCollectionEquality().hash(connectionFailureOrSuccessOption);

  @override
  _$JoinOrCreateCircleStateCopyWith<_JoinOrCreateCircleState> get copyWith =>
      __$JoinOrCreateCircleStateCopyWithImpl<_JoinOrCreateCircleState>(
          this, _$identity);
}

abstract class _JoinOrCreateCircleState implements JoinOrCreateCircleState {
  const factory _JoinOrCreateCircleState(
      {@required
          bool isSearching,
      @required
          bool isJoining,
      @required
          bool isCreating,
      @required
          Option<Either<ConnectionFailure, Unit>>
              connectionFailureOrSuccessOption}) = _$_JoinOrCreateCircleState;

  @override
  bool get isSearching;
  @override
  bool get isJoining;
  @override
  bool get isCreating;
  @override
  Option<Either<ConnectionFailure, Unit>> get connectionFailureOrSuccessOption;
  @override
  _$JoinOrCreateCircleStateCopyWith<_JoinOrCreateCircleState> get copyWith;
}
